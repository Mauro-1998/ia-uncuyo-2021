
# PARTE II
## Ejercicio A
### HILL CLIMB
#### 1) El número (porcentaje) de veces que se llega a un estado de solución óptimo.
PORCENTAJE DE SOLUCIÓN (1000 iteraciones): 1.3%
#### 2) El tiempo de ejecución promedio y la desviación estándar para encontrar dicha solución. (se puede usar la función time.time() de python)
MEDIA DE TIEMPOS DE EJECUCIÓN: 0.722043330852802
#### 3) La cantidad de estados previos promedio y su desviación estándar por los que tuvo que pasar para llegar a una solución
DESVIACIÓN ESTANDAR DE LOS TIEMPOS DE EJECUCIÓN: 1.3389700071292188
ESTADOS VISITADOS HILL CLIMB: 121380
#### 4) Generar un tabla con los resultados para cada uno de los algoritmos desarrollados y guardarla en formato .csv (comma separated value)
ADJUNTADO EN UN UNICO ARCHIVO CSV.
#### 5) Realizar un gráfico de cajas (boxplot) que muestre la distribución de los tiempos de ejecución de cada algoritmo. (ver gráfico de ejemplo)
![Captura de pantalla de 2021-09-16 22-57-51](https://user-images.githubusercontent.com/63267942/133712717-92a23034-9b28-414a-a5b3-08819b768300.png)


### SIMULATED ANNEALING
#### 1) El número (porcentaje) de veces que se llega a un estado de solución óptimo.
PORCENTAJE DE SOLUCIÓN (1000 iteraciones): 0.7000000000000001%
#### 2) El tiempo de ejecución promedio y la desviación estándar para encontrar dicha solución. (se puede usar la función time.time() de python)
MEDIA DE TIEMPOS DE EJECUCIÓN: 0.6372555324009487
#### 3) La cantidad de estados previos promedio y su desviación estándar por los que tuvo que pasar para llegar a una solución
DESVIACIÓN ESTANDAR DE LOS TIEMPOS DE EJECUCIÓN: 0.9769101286336727
ESTADOS VISITADOS: 112407
#### 4) Generar un tabla con los resultados para cada uno de los algoritmos desarrollados y guardarla en formato .csv (comma separated value)
ADJUNTADO EN UN UNICO ARCHIVO CSV.
#### 5) Realizar un gráfico de cajas (boxplot) que muestre la distribución de los tiempos de ejecución de cada algoritmo. (ver gráfico de ejemplo)
![Captura de pantalla de 2021-09-16 22-58-14](https://user-images.githubusercontent.com/63267942/133713231-7b4c5847-a168-4bc4-b614-79d88e691bd7.png)



### ALGORITMO GENÉTICO
#### 1) El número (porcentaje) de veces que se llega a un estado de solución óptimo.
PORCENTAJE DE SOLUCIÓN (1000 iteraciones): 6.6000000000000005%
#### 2) El tiempo de ejecución promedio y la desviación estándar para encontrar dicha solución. (se puede usar la función time.time() de python)
MEDIA DE TIEMPOS DE EJECUCIÓN: 26.342339107484527
#### 3) La cantidad de estados previos promedio y su desviación estándar por los que tuvo que pasar para llegar a una solución
DESVIACIÓN ESTANDAR DE LOS TIEMPOS DE EJECUCIÓN: 24.9090227094415
ESTADOS VISITADOS: 73649
#### 4) Generar un tabla con los resultados para cada uno de los algoritmos desarrollados y guardarla en formato .csv (comma separated value)
ADJUNTADO EN UN UNICO ARCHIVO CSV.
#### 5) Realizar un gráfico de cajas (boxplot) que muestre la distribución de los tiempos de ejecución de cada algoritmo. (ver gráfico de ejemplo)

![Captura de pantalla de 2021-09-16 22-58-24](https://user-images.githubusercontent.com/63267942/133713503-2ca7c619-596b-4ac6-8294-8cd427f0cf10.png)

### ARCHIVO CSV CON LOS RESULTADOS
[datos.csv](https://github.com/Mauro-1998/ia-uncuyo-2021/files/7182092/datos.csv)

## Ejercicio B
## Ejercicio C
El algoritmo más adecuado es el algoritmo genético, ya que es el algoritmo que provee más soluciones y el tiempo requerido para cada solución es el menor de los 3 algoritmos, es decir, logra una mayor eficiencia. 
